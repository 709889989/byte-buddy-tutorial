[[creating-a-class]]
== 创建一个类

任何一个由 Byte Buddy 创建的类型都是通过 `ByteBuddy` 类的实例来完成的。通过简单地调用 `new ByteBuddy()` 就可以创建一个新实例，然后就可以出发了。希望你使用一个集成开发环境，这样在调用一个给定实例的方法时就能得到相应的提示。这样，你的集成开发环境就会引导你完成相应的方法调用，防止手动在 Byte Buddy 文档中查阅某个类的 API。正如之前所说，Byte Buddy 提供了一个领域特定语言，这样就可以尽可能地提高人类可读性。集成开发环境的提示在大部分情况下会指引你到正确的方向。说的够多了，让我们在 Java 编程环境中创建第一个类吧：

[source,{java_source_attr}]
----
DynamicType.Unloaded<?> dynamicType = new ByteBuddy()
  .subclass(Object.class)
  .make();
----

正如前面所设想的，上面的示例代码会创建一个继承至 `Object` 类型的类。这个动态创建的类型与直接扩展 `Object` 并且没有实现任何方法、属性和构造函数的类型是等价的。你可能已经注意到，我们都没有命名动态生成的类型，通常在定义 Java 类时却是必须的。当然，你也可以很容易地明确地命名这个类型：

[source,{java_source_attr}]
----
DynamicType.Unloaded<?> dynamicType = new ByteBuddy()
  .subclass(Object.class)
  .name("example.Type")
  .make();
----

如果没有明确的命名会怎么样呢？Byte Buddy 与 http://en.wikipedia.org/wiki/Convention_over_configuration[约定大于配置] 息息相关，为你提供了我们认为比较方面的默认配置。至于类型命名，Byte Buddy 的默认配置提供了 `NamingStrategy`，它基于动态类型的超类名称来随机生成类名。此外，名称定义在与父类相同的包下，这样父类的包级访问权限的方法对动态类型也可见。如果你将示例子类命名为 `example.Foo`，那么生成的名称将会类似于 `example.Foo$$ByteBuddy$$1376491271`，这里的数字序列是随机的。这个规则的例外情况就是当子类是从 `java.lang` 包下的类扩展时，就是 `Object` 所在的包。Java 的安全模型不允许自定义类型存放在这个命名空间下。因此，默认命名策略下，这些类型名称将会冠以 `net.bytebuddy.renamed` 的前缀。

默认行为也许对你来说并不方便。感谢约定大于配置原则，你总是可以根据你的需要来选择默认行为。这正是 `ByteBuddy` 的优越之处。通过 `new ByteBuddy()` 创建实例，你就创建了整套的默认配置。通过调用在这个配置上的方法，你就可以根据你的需要来订制它。让我们试试：

[source,{java_source_attr}]
----
DynamicType.Unloaded<?> dynamicType = new ByteBuddy()
  .with(new NamingStrategy.AbstractBase() {
    @Override
    public String subclass(TypeDescription superClass) {
        return "i.love.ByteBuddy." + superClass.getSimpleName();
    }
  })
  .subclass(Object.class)
  .make();
----

在上面这里例子中，我们创建了一个新的配置，在类型命名方面，不同于默认配置。匿名类被简单实现为连接 `i.love.ByteBuddy` 和基类的简要名称。当扩展 `Object` 类型时，动态类将被命名为 `i.love.ByteBuddy.Object`。当创建自己的命名策略时，需要特别小心。Java 虚拟机就是使用名字来区分不同的类型的，这正是为什么要避免命名冲突的原因。如果你需要定制命名行为，请考虑使用 Byte Buddy 内置的 `NamingStrategy.SuffixingRandom`，你可以通过引入比默认对你应用更有意义的前缀来定制命名行为。

[[domain-specific-language-and-immutability]]
=== 领域特定语言和不变性

[source,{java_source_attr}]
----
ByteBuddy byteBuddy = new ByteBuddy();
byteBuddy.withNamingStrategy(new NamingStrategy.SuffixingRandom("suffix"));
DynamicType.Unloaded<?> dynamicType = byteBuddy.subclass(Object.class).make();
----


[source,{java_source_attr}]
----
class Foo {
  String bar() { return "bar"; }
}
----


[source,{java_source_attr}]
----
class Foo {
  String bar() { return "foo" + bar$original(); }
  private String bar$original() { return "bar"; }
}
----


[source,{java_source_attr}]
----
new ByteBuddy().subclass(Foo.class)
new ByteBuddy().redefine(Foo.class)
new ByteBuddy().rebase(Foo.class)
----

[[loading-a-class]]
=== 加载类

[source,{java_source_attr}]
----
Class<?> type = new ByteBuddy()
  .subclass(Object.class)
  .make()
  .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
  .getLoaded();
----

[[reloading-a-class]]
=== 重新加载类

[source,{java_source_attr}]
----
class Foo {
  String m() { return "foo"; }
}

class Bar {
  String m() { return "bar"; }
}
----


[source,{java_source_attr}]
----
ByteBuddyAgent.install();
Foo foo = new Foo();
new ByteBuddy()
  .redefine(Bar.class)
  .name(Foo.class.getName())
  .make()
  .load(Foo.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());
assertThat(foo.m(), is("bar"));
----

[[working-with-unloaded-classes]]
=== 操作没有加载的类

[source,{java_source_attr}]
----
package foo;
class Bar { }
----

[source,{java_source_attr}]
----
class MyApplication {
  public static void main(String[] args) {
    TypePool typePool = TypePool.Default.ofClassPath();
    new ByteBuddy()
      .redefine(typePool.describe("foo.Bar").resolve(), // do not use 'Bar.class'
                ClassFileLocator.ForClassLoader.ofClassPath())
      .defineField("qux", String.class) // we learn more about defining fields later
      .make()
      .load(ClassLoader.getSystemClassLoader());
    assertThat(Bar.class.getDeclaredField("qux"), notNullValue());
  }
}
----

[[creating-java-agents]]
=== 创建 Java Agents

[source,{java_source_attr}]
----
class ToStringAgent {
  public static void premain(String arguments, Instrumentation instrumentation) {
    new AgentBuilder.Default()
        .type(isAnnotatedWith(ToString.class))
        .transform(new AgentBuilder.Transformer() {
      @Override
      public DynamicType.Builder transform(DynamicType.Builder builder,
                                              TypeDescription typeDescription,
                                              ClassLoader classloader) {
        return builder.method(named("toString"))
                      .intercept(FixedValue.value("transformed"));
      }
    }).installOn(instrumentation);
  }
}
----
